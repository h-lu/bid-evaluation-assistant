# 智能评标系统技术实现补充指南

> 调研时间：2026年2月20日  
> 内容：技术架构、核心算法、实现要点

---

## 一、系统架构设计

### 1. 总体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                         智能评标系统                             │
├─────────────────────────────────────────────────────────────────┤
│  Presentation Layer                                              │
│  ├── Web端（评标专家界面）                                        │
│  ├── 移动端（专家远程评标）                                       │
│  └── 大屏端（监督展示）                                           │
├─────────────────────────────────────────────────────────────────┤
│  Application Layer                                               │
│  ├── 文件管理模块（上传、解析、存储）                              │
│  ├── 资格审查模块（自动/人工）                                    │
│  ├── 符合性审查模块（技术/商务）                                  │
│  ├── 评分模块（客观/主观）                                        │
│  ├── 异常检测模块（围标串标识别）                                  │
│  └── 报告生成模块                                                │
├─────────────────────────────────────────────────────────────────┤
│  AI Engine Layer                                                 │
│  ├── Document Parser（MinerU/PaddleOCR）                         │
│  ├── LLM Engine（大模型推理）                                    │
│  ├── RAG Engine（检索增强）                                      │
│  ├── Agent Framework（多智能体调度）                              │
│  └── XAI Engine（可解释AI）                                      │
├─────────────────────────────────────────────────────────────────┤
│  Data Layer                                                      │
│  ├── 招标文件库                                                  │
│  ├── 投标文件库                                                  │
│  ├── 法规知识库                                                  │
│  ├── 历史案例库                                                  │
│  └── 专家库                                                      │
└─────────────────────────────────────────────────────────────────┘
```

### 2. 技术栈选型

| 层级 | 技术选型 | 说明 |
|------|----------|------|
| 前端 | Vue3 + Element Plus | 响应式界面 |
| 后端 | FastAPI | 高性能异步框架 |
| 数据库 | PostgreSQL + ChromaDB | 关系型+向量库 |
| 文档解析 | MinerU + PaddleOCR | PDF/图片解析 |
| LLM | GPT-4/Claude/国产大模型 | 多模型适配 |
| RAG | LangChain + ChromaDB | 检索增强 |
| Agent | CrewAI / AutoGen | 多智能体框架 |
| XAI | SHAP + InterpretML | 可解释AI |
| 部署 | Docker + K8s | 容器化部署 |

---

## 二、核心功能实现

### 1. 投标文件解析

**技术流程**：

```python
class DocumentParser:
    def parse_bid_document(self, file_path):
        # 1. 文档类型识别
        doc_type = self.detect_type(file_path)
        
        # 2. 选择解析器
        if doc_type == 'pdf':
            parser = MinerUParser()
        elif doc_type in ['jpg', 'png']:
            parser = PaddleOCRParser()
        elif doc_type in ['doc', 'docx']:
            parser = WordParser()
        
        # 3. 解析文档
        raw_content = parser.parse(file_path)
        
        # 4. 结构化提取
        structured_data = self.extract_structure(raw_content)
        
        # 5. 关键信息抽取
        key_info = self.extract_key_info(structured_data)
        
        return {
            'raw_content': raw_content,
            'structured_data': structured_data,
            'key_info': key_info
        }
    
    def extract_key_info(self, data):
        """抽取关键信息"""
        return {
            'company_info': self.extract_company(data),
            'qualifications': self.extract_qualifications(data),
            'performance': self.extract_performance(data),
            'technical_response': self.extract_technical(data),
            'quotation': self.extract_quotation(data)
        }
```

**关键信息抽取Prompt示例**：

```python
QUALIFICATION_EXTRACTION_PROMPT = """
请从以下投标文件中提取供应商资质信息，以JSON格式返回：

提取字段：
- company_name: 公司名称
- business_license: 营业执照信息（注册号、有效期）
- medical_device_license: 医疗器械经营许可证
- qualification_level: 资质等级
- certifications: 认证证书列表（ISO等）

投标文件内容：
{document_content}

要求：
1. 如某项信息未找到，返回null
2. 日期格式统一为YYYY-MM-DD
3. 只返回JSON，不要有其他文字
"""
```

### 2. 资格审查自动化

**审查规则引擎**：

```python
class QualificationChecker:
    def __init__(self):
        self.rules = self.load_rules()
    
    def check(self, bid_info):
        results = []
        for rule in self.rules:
            result = self.apply_rule(bid_info, rule)
            results.append(result)
        
        return {
            'overall_result': all(r['passed'] for r in results),
            'details': results,
            'explanation': self.generate_explanation(results)
        }
    
    def apply_rule(self, bid_info, rule):
        """应用单条审查规则"""
        if rule['type'] == 'license_validity':
            return self.check_license_validity(bid_info, rule)
        elif rule['type'] == 'credit_record':
            return self.check_credit_record(bid_info, rule)
        elif rule['type'] == 'performance_requirement':
            return self.check_performance(bid_info, rule)
        # ...
```

**规则配置示例**：

```yaml
qualification_rules:
  - id: R001
    name: 营业执照有效性
    type: license_validity
    description: 营业执照必须在有效期内
    check_method: api_call
    api_endpoint: /api/business_license/verify
    required: true
    
  - id: R002
    name: 信用记录核查
    type: credit_record
    description: 不得为失信被执行人
    check_method: external_query
    source: credit_china
    required: true
    
  - id: R003
    name: 业绩要求
    type: performance_requirement
    description: 至少提供3个类似项目业绩
    min_count: 3
    required: true
```

### 3. 智能评分引擎

**客观分计算**：

```python
class ObjectiveScorer:
    def calculate(self, bid_data, scoring_standard):
        scores = {}
        explanations = {}
        
        for item in scoring_standard['objective_items']:
            if item['type'] == 'price':
                score, exp = self.score_price(bid_data['quotation'], 
                                               scoring_standard['benchmark_price'],
                                               item['formula'])
            elif item['type'] == 'performance':
                score, exp = self.score_performance(bid_data['performance'],
                                                     item['criteria'])
            elif item['type'] == 'qualification':
                score, exp = self.score_qualification(bid_data['qualifications'],
                                                       item['criteria'])
            
            scores[item['name']] = score
            explanations[item['name']] = exp
        
        return {
            'total_score': sum(scores.values()),
            'breakdown': scores,
            'explanations': explanations
        }
    
    def score_price(self, quotation, benchmark, formula):
        """价格分计算"""
        if formula == 'lowest_price':
            # 最低价法
            score = (benchmark / quotation) * weight
        elif formula == 'benchmark_deviation':
            # 基准价偏离法
            deviation = abs(quotation - benchmark) / benchmark
            score = max(0, weight - deviation * penalty_factor)
        
        explanation = f"报价：{quotation}万元，基准价：{benchmark}万元，得分：{score:.2f}"
        return score, explanation
```

**主观分辅助（RAG实现）**：

```python
class SubjectiveScorer:
    def __init__(self, vector_store):
        self.vector_store = vector_store
        self.llm = OpenAI()
    
    def generate_score_suggestion(self, bid_data, evaluation_criteria):
        # 1. 检索相似案例
        similar_cases = self.vector_store.similarity_search(
            query=bid_data['technical_response'],
            filter={"category": "historical_evaluations"},
            k=5
        )
        
        # 2. 构建提示
        prompt = f"""
        作为评标专家，请根据以下信息给出技术方案评分建议：
        
        评分标准：
        {evaluation_criteria}
        
        投标方案：
        {bid_data['technical_response']}
        
        历史相似案例参考：
        {similar_cases}
        
        请提供：
        1. 建议得分（0-40分）
        2. 得分理由
        3. 优点分析
        4. 不足之处
        5. 与历史案例的对比
        """
        
        # 3. 生成建议
        suggestion = self.llm.generate(prompt)
        
        return self.parse_suggestion(suggestion)
```

### 4. 异常检测（围标串标识别）

**多维度检测模型**：

```python
class AbnormalDetection:
    def detect(self, all_bids):
        alerts = []
        
        # 1. 硬件特征检测
        alerts.extend(self.check_hardware_fingerprints(all_bids))
        
        # 2. 文本相似度检测
        alerts.extend(self.check_text_similarity(all_bids))
        
        # 3. 报价规律性检测
        alerts.extend(self.check_quotation_pattern(all_bids))
        
        # 4. 企业关联检测
        alerts.extend(self.check_company_relationship(all_bids))
        
        # 5. 时间模式检测
        alerts.extend(self.check_time_pattern(all_bids))
        
        return self.aggregate_alerts(alerts)
    
    def check_text_similarity(self, bids):
        """文本相似度检测"""
        alerts = []
        
        # 使用SimHash/MinHash算法
        for i, bid1 in enumerate(bids):
            for bid2 in bids[i+1:]:
                similarity = self.calculate_similarity(
                    bid1['technical_response'],
                    bid2['technical_response']
                )
                
                if similarity > 0.8:
                    alerts.append({
                        'type': 'high_text_similarity',
                        'severity': 'high' if similarity > 0.9 else 'medium',
                        'companies': [bid1['company'], bid2['company']],
                        'similarity': similarity,
                        'evidence': self.get_similar_sections(bid1, bid2)
                    })
        
        return alerts
    
    def check_quotation_pattern(self, bids):
        """报价规律性检测"""
        quotations = [b['quotation'] for b in bids]
        
        # 检测等差数列
        if self.is_arithmetic_sequence(quotations):
            return [{
                'type': 'arithmetic_quotation',
                'severity': 'high',
                'description': '报价呈等差数列分布',
                'quotations': quotations
            }]
        
        # 检测等比数列
        if self.is_geometric_sequence(quotations):
            return [{
                'type': 'geometric_quotation',
                'severity': 'high',
                'description': '报价呈等比数列分布',
                'quotations': quotations
            }]
        
        return []
```

### 5. RAG知识库构建

**知识库架构**：

```python
class KnowledgeBase:
    def __init__(self):
        self.vector_store = ChromaDB()
        self.embedding_model = SentenceTransformer('BAAI/bge-large-zh')
    
    def build(self, data_sources):
        """构建知识库"""
        documents = []
        
        # 1. 法规文档
        regulations = self.load_regulations(data_sources['regulations'])
        documents.extend(self.chunk_documents(regulations, source='regulation'))
        
        # 2. 历史评标案例
        cases = self.load_historical_cases(data_sources['cases'])
        documents.extend(self.chunk_documents(cases, source='case'))
        
        # 3. 招标文件模板
        templates = self.load_templates(data_sources['templates'])
        documents.extend(self.chunk_documents(templates, source='template'))
        
        # 4. 生成向量并存储
        for doc in documents:
            doc['embedding'] = self.embedding_model.encode(doc['content'])
            self.vector_store.add(doc)
    
    def retrieve(self, query, filters=None, k=5):
        """检索相关知识"""
        query_embedding = self.embedding_model.encode(query)
        
        results = self.vector_store.similarity_search(
            query_embedding=query_embedding,
            filters=filters,
            k=k
        )
        
        return results
```

**文档Chunking策略**：

```python
def chunk_documents(documents, chunk_size=500, overlap=50):
    """文档分块策略"""
    chunks = []
    
    for doc in documents:
        # 按章节分割（对于结构化文档）
        if doc['type'] == 'structured':
            sections = doc['content'].split('\n## ')
            for section in sections:
                if len(section) > chunk_size:
                    # 长章节进一步分割
                    sub_chunks = [section[i:i+chunk_size] 
                                 for i in range(0, len(section), chunk_size-overlap)]
                    chunks.extend(sub_chunks)
                else:
                    chunks.append(section)
        else:
            # 非结构化文档按字数分割
            text = doc['content']
            for i in range(0, len(text), chunk_size-overlap):
                chunks.append(text[i:i+chunk_size])
    
    return chunks
```

---

## 三、关键技术实现细节

### 1. 大模型调用优化

**多模型适配层**：

```python
class LLMProvider:
    def __init__(self):
        self.providers = {
            'openai': OpenAIProvider(),
            'anthropic': ClaudeProvider(),
            'deepseek': DeepSeekProvider(),
            'qwen': QwenProvider()
        }
    
    async def generate(self, prompt, model='default', **kwargs):
        provider = self.get_provider(model)
        
        # 重试机制
        for attempt in range(3):
            try:
                response = await provider.generate(prompt, **kwargs)
                return response
            except RateLimitError:
                await asyncio.sleep(2 ** attempt)
            except Exception as e:
                if attempt == 2:
                    raise
        
    def get_provider(self, model):
        if model == 'default':
            return self.providers['deepseek']
        return self.providers.get(model)
```

**提示词工程最佳实践**：

```python
# 使用结构化提示词
SYSTEM_PROMPT = """你是一位资深的医疗器械招投标评标专家，拥有20年从业经验。
你的职责是协助评标专家进行合规性审查和评分建议。
请基于客观事实和招标文件要求给出专业意见。"""

# Few-shot示例
FEW_SHOT_EXAMPLES = [
    {
        "input": "技术方案包含实施计划、人员配置、售后服务",
        "output": json.dumps({
            "completeness_score": 8,
            "rationale": "方案基本完整，但缺少风险评估与应对措施"
        })
    },
    # ...
]

def build_prompt(task, context, examples=None):
    prompt = f"{SYSTEM_PROMPT}\n\n"
    
    if examples:
        prompt += "参考示例：\n"
        for ex in examples:
            prompt += f"输入：{ex['input']}\n输出：{ex['output']}\n\n"
    
    prompt += f"任务：{task}\n\n"
    prompt += f"上下文：{context}\n\n"
    prompt += "请以JSON格式输出结果。"
    
    return prompt
```

### 2. 并发与性能优化

**异步处理**：

```python
async def process_multiple_bids(bids, max_concurrent=5):
    """并发处理多个投标文件"""
    semaphore = asyncio.Semaphore(max_concurrent)
    
    async def process_with_limit(bid):
        async with semaphore:
            return await process_bid(bid)
    
    tasks = [process_with_limit(bid) for bid in bids]
    results = await asyncio.gather(*tasks)
    
    return results
```

**缓存策略**：

```python
from functools import lru_cache
import hashlib

@lru_cache(maxsize=1000)
def get_vector_embedding(text):
    """缓存向量嵌入结果"""
    return embedding_model.encode(text)

def cache_key(*args):
    """生成缓存键"""
    key_str = str(args)
    return hashlib.md5(key_str.encode()).hexdigest()
```

### 3. 数据安全与合规

**敏感数据脱敏**：

```python
class DataMasker:
    def mask_company_info(self, text):
        """公司信息脱敏"""
        # 公司名称脱敏
        text = re.sub(r'([\u4e00-\u9fa5]{2,})有限公司', r'\1***公司', text)
        # 联系人脱敏
        text = re.sub(r'联系人[：:]\s*(\S{1})\S+', r'联系人：\1**', text)
        # 电话脱敏
        text = re.sub(r'(1\d{2})\d{4}(\d{4})', r'\1****\2', text)
        return text
    
    def mask_financial_data(self, text):
        """财务数据脱敏"""
        # 金额脱敏（保留量级）
        text = re.sub(r'(\d+)\d{4,}(元|万元)', r'\1****\2', text)
        return text
```

**审计日志**：

```python
class AuditLogger:
    def log_evaluation(self, user_id, bid_id, action, details):
        """记录评标操作日志"""
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'user_id': user_id,
            'bid_id': bid_id,
            'action': action,
            'details': details,
            'ip_address': get_client_ip(),
            'session_id': get_session_id()
        }
        
        # 写入只读审计日志库
        self.audit_db.insert(log_entry)
        
        # 重要操作发送实时告警
        if action in ['score_submitted', 'disqualify']:
            self.send_alert(log_entry)
```

---

## 四、部署与运维

### 1. 容器化部署

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY src/ ./src/
COPY config/ ./config/

# 设置环境变量
ENV PYTHONPATH=/app
ENV MODEL_CACHE=/app/cache

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "src.web.app:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 2. 监控与告警

```python
# 性能监控
from prometheus_client import Counter, Histogram, Gauge

evaluation_counter = Counter('bid_evaluations_total', 'Total bid evaluations')
evaluation_duration = Histogram('evaluation_duration_seconds', 'Evaluation duration')
active_evaluations = Gauge('active_evaluations', 'Number of active evaluations')

# 业务监控
alert_rules = {
    'high_similarity_alert': {
        'condition': 'text_similarity > 0.9',
        'severity': 'critical',
        'notify': ['admin', 'supervisor']
    },
    'score_deviation_alert': {
        'condition': 'score_std > 15',
        'severity': 'warning',
        'notify': ['expert_lead']
    }
}
```

---

## 五、测试与验证

### 1. 单元测试

```python
import pytest

class TestQualificationChecker:
    def test_license_validity_check(self):
        checker = QualificationChecker()
        bid_info = {
            'business_license': {
                'number': '91110000123456789X',
                'valid_until': '2026-12-31'
            }
        }
        
        result = checker.check_license_validity(bid_info)
        
        assert result['passed'] == True
        assert 'license_valid' in result['details']
    
    def test_expired_license(self):
        checker = QualificationChecker()
        bid_info = {
            'business_license': {
                'valid_until': '2024-01-01'  # 已过期
            }
        }
        
        result = checker.check_license_validity(bid_info)
        
        assert result['passed'] == False
```

### 2. 集成测试

```python
@pytest.mark.integration
def test_full_evaluation_workflow():
    # 准备测试数据
    tender_file = 'tests/data/sample_tender.pdf'
    bid_files = ['tests/data/bid_a.pdf', 'tests/data/bid_b.pdf']
    
    # 执行完整流程
    system = BidEvaluationSystem()
    
    # 解析招标文件
    tender = system.parse_tender(tender_file)
    
    # 解析投标文件
    bids = [system.parse_bid(f) for f in bid_files]
    
    # 执行评审
    results = system.evaluate(tender, bids)
    
    # 验证结果
    assert len(results) == 2
    assert all('score' in r for r in results)
    assert all('explanation' in r for r in results)
```

---

## 六、参考资料

1. LangChain官方文档：https://python.langchain.com/
2. ChromaDB文档：https://docs.trychroma.com/
3. SHAP文档：https://shap.readthedocs.io/
4. FastAPI文档：https://fastapi.tiangolo.com/
5. MinerU GitHub：https://github.com/opendatalab/MinerU
6. PaddleOCR文档：https://github.com/PaddlePaddle/PaddleOCR
